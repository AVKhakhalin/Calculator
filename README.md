# Scientific calculator
<h1>Описание по-русски:</h1>

"Научный калькулятор" ("Scientific calculator")
=======

<p align="center">
<img  src="https://user-images.githubusercontent.com/78661461/195310117-3e59ecec-d4d3-4f87-965f-fab9bb093188.png">
<img  src="https://user-images.githubusercontent.com/78661461/195310165-b6c67cf8-9d75-4b2c-86be-7a78fddb2417.png">
</p>

Приложение "Научный калькулятор" (далее, калькулятор) предназначено, в первую очередь, для разработчиков с целью внедрения в свои приложения возможности проведения достоверных вычислений. Поэтому оно имеет минимально возможный API для использования - 14. Оно не использует никаких сторонних бесплатных библиотек, а также целиком написано на Java (версии 8, "VERSION_1_8"). Помимо этого, данное приложение имеет своё решение по отображению элементов калькулятора на базе паттерна MVP, предназначенное для только для апробирования его возможностей и быстрой проверки его функциональности. Для этого имплементируются следующие стандартные библиотеки:
```
    implementation libs.androidX.appcompat
    implementation libs.design.material
    implementation libs.design.constrlayout
```    
Достоверность вычислений обеспечивается универсальными структурами данных, однозначным и ясным алгоритмом обработки исходных данных, их проверкой на этапе ввода и в процессе вычислений, а также наличием Unit-, Espresso-тестов. Для проведения тестов имплементируются следующие стандартные библиотеки:
```
    // Test
    testImplementation libs.tests.junit
    androidTestImplementation libs.tests.ext
    androidTestImplementation libs.tests.runner
    androidTestImplementation libs.tests.espressocore
    implementation fileTree(dir: libs.tests.filetreedir, include: libs.tests.filetreeinclude)
    // Mockito
    testImplementation libs.tests.mockitocore
    testImplementation libs.tests.mockitoinline
    testImplementation (libs.tests.mockitokotlin) {
        exclude group: 'org.jetbrains.kotlin'
        exclude group: 'org.mockito'
    }
    // Robolectric
    testImplementation libs.tests.robolectric
    testImplementation libs.tests.robolectriccore
    testImplementation libs.tests.robolectricrunner
    testImplementation libs.tests.robolectricjunit
    testImplementation libs.tests.robolectrictruth
    testImplementation libs.tests.robolectricespressocore
    testImplementation libs.tests.robolectricespressointents
```
Оригинальностью калькулятора является возможность редактирования только целой или только дробной части числа: можно отдельно задавать, удалять целую часть числа, отдельно задавать и удалять дробную часть числа. Это зависит от нажатия на кнопку ",". При её нажатии калькулятор, помимо указания точки в числе, переводится в режим работы с дробной частью числа. При повторном её нажатии калькулятор возвращается обратно в режим работы с целой частью числа. По умолчанию, включается режим работы с целой частью числа.

Демонстрация работы научного калькулятора:

[![Демонстрация работы научного калькулятора "Scientific calculator"](https://user-images.githubusercontent.com/78661461/195307027-10a5d381-51d2-49eb-98ae-a6a8dfd57d2b.png)](https://youtu.be/QF8zFqkLsFA)

## Достоверность вычислений

### Используемые структуры данных

Логика калькулятора состоит из следующих классов и интерфейсов:

1. Интерфейс с основными методами работы пользователя с калькулятором - "CalcLogic". Основные методы, через которые задаются, корректируются и обрабатываются исходные данные:
```
    void setCurZapitay();
        Перевести калькулятор в режим работы с целой частью числа (true) или с его дробной частью (false)

    boolean getPressedZapitay();
        Получить текущее значение режима работы с целой (true) и дробной чатью (false) числа

    double addNumeral(int newNumeral);
        Добавить число из одной цифры или ещё одну цифру к текущему числу; 
        в зависимости от режима работы с целой или с дробной частью, добавление происходит или в целую часть, или в дробную часть. 
        Здесь "newNumeral" - это цифра от 0 до 9

    void clearAll();
        Удаление всей введённой строки

    boolean clearOne();
        Удаление цифры в числе или элемента - скобки, числа (состоящего из 1 цифры), функции. 
        В зависимости от режима работы с целой или с дробной частью, 
        удаляется или 1 цифра в целой части, или 1 цифра в дробной части числа

    boolean clearTwo();
        Удаление текущего элемента - скобки, числа, функции

    void setNewAction(Constants.ACTIONS action);
        Задание действия

    void changeSign();
        Изменение знака числа или функции (для действий «плюс» и «минус» 
        эта операция также приводит к их смене на противоположное действие)

    String setNewFunction(Constants.FUNCTIONS typeFuncInBracket);
        Создание открывающей скобки (с параметром Constants.FUNCTIONS.FUNC_NO) и функции

    String closeBracket();
        Создание закрывающей скобки

    void setMaxNumberSymbolsInOutputTextField(int maxNumberSymbolsInOutputTextField);
        Установка максимального количества символов, из которых состоит конечный результат

    void calculate();
        Вычисление результата на основании введённой строки скобок, чисел, действий и функций

    String getFinalStringResult();
        Получение результата вычислений в виде переменной типа String. 
        Если есть ошибки во введённой строке, то выводится ""

    double getFinalDoubleResult();
        Получение результата вычислений в виде переменной типа double. 
        Если есть ошибки во введённой строке, то выводится 0.0

    String createOutput();
        Вывод информации о введённой строке

    Constants.ERRORS_IN_STRING getErrorCode();
        Получение кода ошибки

    void clearErrorCode();
        Очистка кода ошибки во введённых данных для проведения повторного расчёта результата
```
2. Интерфейс с основными константами, необходимыми для работы логики калькулятора - "Constants".

3. Интерфейс с методом для передачи во вью сообщения об ошибке в работе калькулятора - "ErrorMessages".

4. Класс с основной логикой вычислений калькулятора - "CalcLogicImpl". Этот класс имплементирует все выше приведённые интерфейсы "CalcLogic", "Constants", "ErrorMessages". 
В зависимости от выбранного разработчиком способа сохранения класса "CalcLogicImpl", ему может быть имплементированы интерфейсы "Serializable" и(или) "Parcelable". В калькуляторе данные при повороте экрана сохраняются в "Bundle", и для этого был выбран интерфейс "Serializable".

5. Универсальный класс для сохранения одиночного элемента исходных данных - "InputData". Каждое действие в калькуляторе по добавлению новых исходных данных (одиночное нажатие на соответствующую кнопку с цифрой, действием, скобкой или функцией) приводит или к созданию нового класса "InputData", или к его модификации. Класс "InputData" имеет следующие поля:
```
    private boolean isBracket;
        Признак, является ли данный элемент скобкой: true = да; false = нет;
        открывающаяся скобка является пустым объектом, 
        в неё потом размещается результат вычислений всех операций в данной скобке; 
        пустой объект имеет вначале value = 0d;
        закрывающая скобка всегда создаётся отдельным элементом без числа;
        последний объект в скобке имеет свойство isBracket = true, что говорит о том, что скобка закрылась

    private boolean isClose;
        Признак закрывающей скобки; у последнего элемента в скобке будет isClose = true, 
        а у остальных элементов в скобке isClose = false открывающая скобка определяется 
        по двум признакам: isBracket = true; isClose = true

    private FUNCTIONS typeFuncInBracket;
        Тип функции, которую нужно применить ко всей скобке. 
        Все типы фукнции описаны в интерфейсе Constants

    private int bracketLevel;
        Уровень скобки: чем выше уровень, тем более глубоко вложена данная скобка в другие скобки; 
        начальный уровень - 0

    private int sign;
        Знак числа: либо +1, либо -1; по умолчанию, значение +1

    private double value;
        Числовое значение

    private final LinkedList<Integer> integerPartValue;
        Список цифр целой части вводимого числа

    private final LinkedList<Integer> realPartValue;
        Список цифр дробной части вводимого числа

    private boolean isValue;
        Признак задания числа; 
        по умолчанию, все числа задаются 0d; 
        если хотя бы одну цифру в число внесли, то isValue = true; 
        по-умолчанию isValue = false

    private ACTIONS action;
        Производимые действия над числом (по умолчанию стоит сумма ACT_PLUS):
        ACT_PERC_MULTY   - вычисление произведения на процент от числа (ACT_PERC_MULTY);
        ACT_PERC_DIV     - вычисление деления на процент от числа (ACT_PERC_DIV);
        ACT_PERC_MINUS   - вычисление вычитания процента от числа (ACT_PERC_MINUS);
        ACT_PERC_PLUS    - вычисление сложения с процентом от числа (ACT_PERC_PLUS);
        ACT_STEP         - возведение в степень (ACT_STEP);
        ACT_MULTY        - умножение (ACT_MULTY);
        ACT_DIV          - деление (ACT_DIV);
        ACT_MINUS        - вычитание (ACT_MINUS);
        ACT_PLUS         - сложение (ACT_PLUS)

    private boolean isPercent;
        признак того, что данный элемент является процентом: true = да; false = нет

    private int numberZapitay;
        Количество разрядов после запятой. По умолчанию -1, что означает, что разрядов нет.
        При нажатии на кнопку с запятой, к данному числу прибавляется единица 
        и оно становится равным нулю. При дальнейшем нажатии (после запятой) на любую из цифр, 
        к numberZapitay прибавляется единица и к числу прибавляется следующая величина: 
        Math.pow(10, -numberZapitay) * NUMERAL

    private boolean turnOffZapitay;
        Выключение режима ввода дробных знаков при повторном нажатии на запятую. 
        По умолчанию, turnOffZapitay = true, т.е. вводятся только цифры целого числа. 
        Если один раз нажать на запятую, то turnOffZapitay = false и начнут вводиться цифры после запятой. 
        Если ещё раз нажать на запятую, то turnOffZapitay = false 
        опять начнут вводиться цифры только в целую часть числа и т.д.
```

Исходные данные, записываемые в класс "InputData", состоят из следующих элементов:

1. Открывающая скобка "(" - скобка отделяющая ранее введённые данные от вновь вводимых данных. Каждая открытая скобка имеет свой "bracketLevel". Если скобок совсем нет, то у вводимых данных "bracketLevel" == 0. Каждая новая открывающая скобка увеличивает свой и текущий "bracketLevel" на единицу. После обработки содержимого каждой скобки, конечное число устанавливается вместо открывающей скобки. Фактически, скобка сворачивается в один элемент, а открывающая скобка становится обычным числом.

2. Закрывающая скобка ")"  - скобка обозначающая границу ранее введенных данных от вновь вводимых данных. Каждая закрывающая скобка имеет свой "bracketLevel", как и открывающая скобка. Каждая новая закрывающая скобка имеет "bracketLevel" такой же, как и у открывающей скобки, а текущий уровень "bracketLevel" уменьшает на единицу.

3. Число - положительное или отрицательное, вещественное или целое, состоящее из одной или нескольких цифр, число. Когда пользователь нажимает цифры калькулятора, то, в зависимости от режима, в котором он находится (задание целой части числа или дробной части числа), задаётся или целая, или дробная часть числа. У каждого числа есть свой знак. По умолчанию, он положительный. Но если при задании числа вызвать метод "changeSign()", то его знак сменится на противоположный.

4. Действие - это арифметическая операция над числами, возведение в степень, взятие процента. Каждое действие имеет свой приоритет выполнения. Ниже представлены реализованные действия в порядке убывания приоритета:
```
    ДЕЙСТВИЯ С САМЫМ ВЫСОКИМ ПРИОРИТЕТОМ

    ACT_PERC_MULTY - вычисление произведения на процент от числа (ACT_PERC_MULTY);
    ACT_PERC_DIV - вычисление деления на процент от числа (ACT_PERC_DIV);
    ACT_PERC_MINUS - вычисление вычитания процента от числа (ACT_PERC_MINUS);
    ACT_PERC_PLUS - вычисление сложения с процентом от числа (ACT_PERC_PLUS);
    ACT_STEP - возведение в степень (ACT_STEP);
    ACT_MULTY - умножение (ACT_MULTY);
    ACT_DIV - деление (ACT_DIV);
    ACT_MINUS - вычитание (ACT_MINUS);
    ACT_PLUS - сложение (ACT_PLUS)

    ДЕЙСТВИЯ С САМЫМ НИЗКИМ ПРИОРИТЕТОМ
```
Исключением являются только две операции: деление и умножение. Они выполняются в зависимости от того, какая операция была поставлена раньше другой. Например, если вначале пользователь поставил между двумя числами A и B действие "ACT_DIV", а потом поставил действие "ACT_MULTY" (умножение) и добавил ещё одно число C, то сначала A будет разделено на B, а потом результат будет умножен на C. Если же между двумя числами A и B поставить действие "ACT_MULTY" (умножение), а потом поставить действие "ACT_DIV" (деление) для числа C, то вначале A будет умножено на B, а потом результат будет поделен на C.

Для работы с процентами в текущей версии приложения используется следующая логика: число A изменяется в соответствии с одной из 4 арифметических операций (умножение, деление, вычитание или сложение) на число B, которое является процентом от числа A. Например, 100+10%=110, здесь A=100, B=10. Такая схема позволяет учесть отрицательный процент. Например, -6*100%=36, потому что -6*(-6)=36, а если процент будет отрицательным, то получится -6*(-100)%=-36, потому что -6*6=-36. 

Важно: вычисление процента без скобок или внутри скобки без других скобок производится самым первым среди других действий, потому что оно содержит в себе число, являющееся процентом от другого числа. Поэтому на это число не может быть применено никакое другое действие от другого числа. Потому что действия производятся между числами, а не между числом и процентом числа. 

Важно: обычное получение процента от числа по схеме A%B пока не реализовано.

Поэтому для работы с процентами важно, чтобы перед установкой знака процента были уже введены два числа. Они могу быть введены как без скобок, так и содержаться внутри скобок. Но важно, чтобы было два числа именно на том уровне "bracketLevel", на котором применяется знак %. В программе реализовано автоматическое определение типа используемого действия, в соответствии с тем действием, которое стоит между числами A и B. Поэтому к числу B всегда применяется действие "ACT_PERC_MULTY", которое в зависимости от действия между числами A и B, либо остаётся "ACT_PERC_MULTY" (когда между A и B стояло действие "ACT_MULTY"), либо превращается в "ACT_PERC_DIV" (когда между A и B стояло действие "ACT_DIV"), либо превращается в "ACT_PERC_MINUS" (когда между A и B стояло действие "ACT_PERC_MINUS"), либо превращается в "ACT_PERC_PLUS" (когда между A и B стояло действие "ACT_PLUS"). Учитывая равноправность действий "ACT_PERC_MULTY" и "ACT_PERC_DIV" (по аналогии с умножением и делением), запрещено в одной строчке без скобок или внутри скобки использовать эти действия более одного раза. Для вторичного использования "ACT_PERC_MULTY" или "ACT_PERC_DIV" нужно его обернуть в отдельную скобку. Например, (100+10%)*9%=1089.

Для возведения в степень сначала с помощью однократного или многократного вызова метода "addNumeral(int newNumeral)" (здесь newNumeral - цифра от 0 до 9) и метода setCurZapitay() задаётся число A, которое нужно возвести в степень, потом вызывается метод "setNewAction(Constants.ACTIONS.ACT_STEP)" и задаётся опять с помощью методов "addNumeral(int newNumeral)" и "setCurZapitay()" другое число B – показатель степени.

5. Функция - это сложное действие, которое требует использования встроенных в Java или собственных функций, а также отгорожено от остальных элементов скобками. Фактически, функция представляет собой такую же скобку, но при сворачивании скобки, к конечному числу применяется установленная пользователем функция. Результат функции - число - также, размещается вместо открытой скобки. В текущей версии калькулятора заложена пока только одна функция - извлечение квадратного корня. Добавление новый функций - задача не сложная, и она будет описана в разделе "Добавление новой функции".

### Алгоритм обработки исходных данных

Сначала проводятся вычисления в скобках с максимальным уровнем вложенности (отсутствие скобок является нулевым уровнем вложенности "bracketLevel"). Содержимое скобки, как и сами скобки,  удаляются, а вместо ранее открытой скобки устанавливается результат - число на месте открытой скобки. Потом аналогичные вычисления проводятся для скобок на один уровень ниже и так далее, пока уровень скобок не дойдёт до нуля. В результате, вся введённая строка оказывается обработанной, и вместо неё получается число. Калькулятор хранит каждое вводимое число в виде двух списков цифр целой части числа "integerPartValue" и вещественной части числа "realPartValue". Это позволяет корректно отображать всю историю вводимых чисел.

### Проверка исходных данных на этапе их ввода

Для достижения достоверных вычислений, в калькуляторе предусмотрен следующий анализ вводимых данных и уведомление пользователя об ошибке ввода исходных данных:

1. Попытка поставить число сразу же после скобки без указания действий с ним (код ошибки: "NUMBER_AFTER_BRACKET").

2. Попытка ввода нескольких нулей в целую часть числа, если нет перед ними другой цифры, отличной от нуля (код ошибки: "MANY_ZERO_IN_INTEGER_PART").

3. Попытка применить действие не к числу, например, когда пользователь хочет начать ввод исходных данных с действия в случае отсутствия скобок или в текущей скобке (код ошибки: "INPUT_NUMBER_FIRST"). В классе "InputData" есть поле "sign". Изначально можно ввести только положительное число. Чтобы оно стало отрицательным, нужно вызвать метод "changeSign()", и тогда слева от числа появится знак минус, а само число возьмётся в скобки. Однако, если число ещё не вводилось, то вызов метода "changeSign()" приведёт к следующей ошибке (см. п. 4).

4. Попытка сменить знак числа, не введя его (код ошибки: "CHANGE_SIGN_EMPTY"). Сначала нужно ввести число, а потом менять его знак. У нуля не может быть отрицательного знака, поскольку это лишено смысла. Если мы ввели нуль и хотим изменить его знак, то получим данную ошибку.

5. Попытка применения процента без ввода чисел или при введении только одного числа (код ошибки: "PERCENT_NEEDS_TWO_NUMBERS"). Для вычисления изменения числа на процент от него нужно ввести два числа и любую следующую арифметическую операцию между ними: *, /, +, -.

6. Попытка создать новую открытую скобку, не указав действия с этой скобкой (код ошибки: "OPEN_BRACKET_ON_EMPTY_ACTION"). Если открытая скобка ставится сразу же после числа, то непонятно, какое действие применить к ранее поставленному числу со стороны числового значения в данной новой скобке. Если же открытая скобка ставится сразу же после открытой скобки, то данная ошибка не возникает.

7. Попытка поставить закрывающую скобку, если предварительно не поставить ей соответствующую открывающую скобку (код ошибки: "CLOSE_BRACKET_ON_EMPTY_OPEN_BRACKET"). Закрывающую скобку можно ставить только для конкретной открывающей скобки.

8. Попытка закрыть пустую скобку, в скобке, как минимум, должно быть какое-то число (код ошибки: "CLOSE_BRACKET_ON_EMPTY"). Данная ошибка возникает, когда пользователь пытается закрыть только что открытую скобку. Таким образом, создать скобку, в которой не будет никакого численного значения, что не имеет смысла.

9. Попытка поставить закрывающую скобку на действии без указания числа (код ошибки: "CLOSE_BRACKET_ON_ACTION_WITHOUT_NUMBER").

10. Попытка ввести знак процента большое одного раза без скобок или в рамках одной скобки (код ошибки: "MULTIPLE_PERCENT_IN_BRACKET"). Если нужно произвести вычисление процента несколько раз, то нужно каждую такую конструкцию оборачивать в скобки. 

### Проверка исходных данных на этапе вычислений

Для достижения достоверных вычислений, в калькуляторе предусмотрен следующий анализ введённых данных и уведомление пользователя об ошибке в процессе вычислений:

1. Никаких ошибок нет (код ошибки: "NO").

2. Корень у отрицательного числа (код ошибки: "SQRT_MINUS").

3. Количество открытых скобок и закрытых скобок не равно друг другу (код ошибки: "BRACKET_DISBALANCE").

4. Деление на ноль (код ошибки: "ZERO_DIVIDE").

### Проведённые тесты

Для проведения корректности работы калькулятора написаны Unit-тесты и Espresso-тесты.

#### Unit-тесты
Проверка класса MainActivity():
1. Проверка корректности создания класса MainActivity - activity_AssertNotNull().
2. Проверка прохождения MainActivity через состояние onResume() - activity_IsResumed().
3. Проверка наличия в макете MainActivity фона с id "_background_theme" - activityBackgroundTheme_NotNull().
4. Проверка наличия в макете MainActivity элементов калькулятора - activityDayElements_NotNull().
5. Проверка наличия текста в поле text для элементов калькулятора - activityDayElements_HasText().
6. Проверка видимости элемента калькулятора с фоном - activityBackgroundTheme_IsVisible().
7. Проверка видимости элементов калькулятора - activityDayElements_AreVisible().
8. Проверка работоспособности элементов калькулятора - activityElements_IsWorking().
9. Проверка работоспособности метода setInputedHistoryText() - acitivitySetInputedHistoryText_IsWork().
10. Проверка работоспособности метода setOutputResultText() - acitivitySetOutputResultText_IsWork().

Проверка класса MainPresenter():
1. Провека работоспособности метода onAttach() - onAttach_Test().
2. Провека работоспособности метода onDetach() - onDetach_Test().

Проверка класса CalcLogicImpl из класса MainPresenter():
1. Проверка работоспособности метода addNumeral(): 1234567890 - addNumeral_Test().
2. Проверка корректности выполнения метода createOutput(): 2 - createOutput_Test().
3. Проверка корректности выполнения метода getFinalResult(): 2=2 - getFinalResult_Test().
4. Проверка корректности выполнения setBracketOpen(): (  - setBracketOpen_Test().
5. Проверка корректности выполнения setBracketClose(): (1) - setBracketClose_Test().
6. Проверка корректности выполнения setBracketClose() при попытке её закрыть в самом начале строки: ) - setBracketClose_IN_BEGIN_ROW_Test().
7. Проверка корректности выполнения действия возведения в степень: 2^3=8 - setNewAction_ACT_STEP_Test().
8. Проверка корректности выполнения действия произведения на процент от числа: 9*10%=8,1 - setNewAction_ACT_PERS_MULTY_Test().
9. Проверка корректности выполнения действия деления на процент от числа: 9/10%=10 - setNewAction_ACT_PERS_DIV_Test().
10. Проверка корректности выполнения действия вычитания процента от числа: 9-20%=7.2 - setNewAction_ACT_PERS_MINUS_Test().
11. Проверка корректности выполнения действия сложения с процентом от числа: 9+20%=10.8 - setNewAction_ACT_PERS_PLUS_Test().
12. Проверка корректности выполнения действия умножения: 8*7=56 - setNewAction_ACT_MULTY_Test().
13. Проверка корректности выполнения действия деления: 6/2=3 - setNewAction_ACT_DIV_Test().
14. Проверка корректности выполнения действия вычитания: 1-1=0 - setNewAction_ACT_MINUS_Test().
15. Проверка корректности выполнения действия сложения: 1+1=2 - setNewAction_ACT_PLUS_Test().
16. Проверка установки максимального количества символов для отображения в результирующем поле: 1234567890123=1,234568e+12, 1234567890123=1,235e+12 - setMaxNumberSymbolsInOutputTextField_Test().
17. Проверка корректности работы метод calculate(): 1+2*3-5/2=4.5 - calculate_Test().
18. Проверка корректности работы метода setEqual(): 1+2*3-5/2=4.5 - setEqual_Test().
19. Проверка корректности работы метода setCurZapitay(): 12.2 - setCurZapitay_Test().
20. Проверка корректности работы метода getPressedZapitay(): 1.2 - getPressedZapitay_Test().
21. Проверка корректности работы метода clearAll(): 12"C" - clearAll_Test().
22. Проверка корректности работы метода clearOne(): 12"<-" - clearOne_Test().
23. Проверка корректности работы метода clearTwo(): 1-2"<--" - clearTwo_Test().
24. Проверка корректности работы метода changeSign(): 1"+/-" - changeSign_Test().
25. Проверка корректности выполнения setNewFunction(): √(4) - setNewFunction_Test().
26. Проверка корректности выполнения getError() без ошибок: 4 - getError_NO_ERRORS_Test().
27. Проверка корректности выполнения getError() для подкоренного выражения: √((-4)) - getError_SQRT_MINUS_Test().
28. Проверка корректности выполнения getError() для равенства открытых и закрытых скобок: (4 - getError_EQUALS_OPEN_CLOSED_BRACKETS_Test().
29. Проверка корректности выполнения getError() для деления на ноль: 4/0 - getError_ZERO_DIVIDE_Test().
30. Проверка корректности выполнения showErrorInputting() для простановки числа сразу же после скобки без указания действий с ним: (5)1 - showErrorInputting_NUMBER_AFTER_BRACKET_Test().
31. Проверка корректности выполнения showErrorInputting() для показа уведомления о том, что для задания нулевой целой части числа вполне хватит и одного нуля: 00 - showErrorInputting_MANY_ZERO_IN_INTEGER_PART_Test().
32. Проверка корректности выполнения showErrorInputting() для показа уведомления о том, что число не введено  перед действием (^, %, *, /, -, +): - showErrorInputting_INPUT_NUMBER_FIRST_Test().
33. Проверка корректности выполнения showErrorInputting() для показа уведомления о том, что для применения процента нужно ввести два числа и любую следующую арифметическую операцию между ними (*, /, +, -): %, 1% - showErrorInputting_PERCENT_NEEDS_TWO_NUMBERS_Test().
34. Проверка корректности выполнения showErrorInputting() для показа уведомления о том, что нельзя производить смену знака, предварительно не задав число или функцию: (1)"+/-" - showErrorInputting_CHANGE_SIGN_EMPTY_Test().
35. Проверка корректности выполнения showErrorInputting() для показа уведомления о том, что нельзя создать новую открытую скобку, потому что не указано перед скобкой действие: (1)( - showErrorInputting_OPEN_BRACKET_ON_EMPTY_ACTION_Test().
36. Проверка корректности выполнения showErrorInputting() для показа уведомления о том, что нельзя поставить закрывающую скобку, если предварительно не поставить ей соответствующую открывающую скобку: (1)) - showErrorInputting_CLOSE_BRACKET_ON_EMPTY_OPEN_BRACKET_Test().
37. Проверка корректности выполнения showErrorInputting() для пустого выражения в скобках: () - showErrorInputting_CLOSE_BRACKET_ON_EMPTY_Test().
38. Проверка корректности выполнения showErrorInputting() для показа уведомления о том, что нельзя закрывающую скобку ставить на действии без указания числа: (1+) - showErrorInputting_CLOSE_BRACKET_ON_ACTION_WITHOUT_NUMBER_Test().
39. Проверка корректности выполнения showErrorInputting() для показа уведомления о том, что без скобок или в рамках одной скобки нельзя вводить знак процента больше одного раза. Если нужно произвести вычисление процента несколько раз, то нужно каждую такую конструкцию оборачивать в отдельную скобку: 1+2%+3% - showErrorInputting_MULTIPLE_PERCENT_IN_BRACKET_Test().
40. Проверка корректности выполнения getInit() - getInit_Test().
41. Проверка корректности задания процента после скобки с процентом: 6+(6+5%)% - setPercentAfterBracketWithPercent_Test().
42. Проверка корректности задания процента во второй скобке подряд: 7+(6+5%)+(6+5%) - setPercentIntoTwoBrackets_Test().
43. Проверка корректности задания процента в первой скобке и без скобки: (7+4%)+5% - setPercentIntoFirstBracketAndWithoutBracket_Test().
44. Проверка корректности задания пустых скобок: (((6+5))+(5)) - emptyBracketSet_Test().
45. Проверка корректности задания пустых скобок в различной комбинации уровней: ((((6+5)))+((5))-4) - emptyBracketWithDifferentLevelsSet_Test().
46. Проверка возможности поставить несколько нулей в целой части числа: 0000.1 - setMultipleZeroInDecimalPartOfNumber_Test().
47. Проверка корректности задания процента после второй скобки: (1)+(1)%.
48. Проверка корректности выполнения showErrorInputting() для показа уведомления о том, что для применения процента после скобки нужно, чтобы другое число было ранее введено до этой скобки:  √(6*4)%.
49. Проверка корректности выполнения showErrorInputting() для показа уведомления о том, что для применения процента после скобки нужно, чтобы другое число было ранее введено до этой скобки: (1)%.



#### Espresso-тесты

Важно: для запуска Espresso-тестов нужно установить в файле "build.gradle" параметрам "compileSdkVersion" и "targetSdkVersion" значения 30.
Написаны следующие Espresso-тесты:
1. Проверка на существование активити - activity_AssertNotNull().
2. Проверка на прохождение в активити метода onResume() - activity_IsResumed().
3. Проверка наличия элемента с картинкой фона - activityBackgroundThemeImageView_NotNull().
4. Проверка наличия элементов калькулятора - activityDayThemeElements_NotNull().
5. Проверка частичного отображения на экране элемента с картинкой фона - activityBackgroundThemeImageView_Displayed().
6. Проверка частичного отображения на экране элементов калькулятора - activityElements_Displayed().
7. Проверка полного отображения на экране элемента с картинкой фона - activityBackgroundThemeImageView_CompletedDisplayed().
8. Проверка полного отображения на экране элементов калькулятора - activityDayThemeElements_CompletedDisplayed().
9. Проверка отображения корректного текста на элементах калькулятора - activityDayThemeElements_IsCorrectText().
10. Проверка корректности работы кнопок калькулятора на большом дисплее (с шириной дисплея >=1080 px): 1234567891.1+√(9*8%/4^2)-((-35689)*988)=1269828623.7 - activityButtonsLargeScreen_IsCorrectWorking().
11. Проверка корректности работы кнопок калькулятора на маленьком дисплее (с шириной дисплея <1080 px): 1234567891.1+√(9*8%/4^2)-((-35689)*988)=1.270e+09 - activityButtonsSmallScreen_IsCorrectWorking().

Важно: при запуске тестов один из тестов activityButtonsLargeScreen_IsCorrectWorking() или activityButtonsSmallScreen_IsCorrectWorking() даст отрицатльный результат, потому что ширина дисплея телефона или эмулятора не может одновременно удовлетворить двум условиям >=1080 px, и <1080 px.


## Установка научного калькулятора в своё приложение

### Интеграция в своё приложение

Для интеграции логики калькулятора в своё приложение нужно сделать следующие шаги:

1. Перенести в свой проект всю папку "core" (с подпапкой "model").

2. Создать метод "showErrorInputting(Constants.ERRORS_INPUTTING errorInputting)" для передачи из логики калькулятора ошибок при вводе исходных данных в презентере, вьюмодели или ещё в другом вспомогательном классе, в зависимости от используемого вами паттерна проектирования MVC, MVP, MVVM, MVI и т.д. Настроить во вью способ отображения сообщений об ошибке. В текущем проекте данная задача решена через "BottomSheetDialogFragment".

3. Передать при создании класса CalcLogicImpl() в его конструктор метод "showErrorInputting()" или использовать любое другое удобное вам решение.

4. Работать с калькулятором через вызов его основных методов, указанных в интерфейсе "CalcLogic".


### Добавление новой функции

Для добавления новой функции в калькулятор нужно следовать подсказкам "*!*" в интерфейсе "Constants" и классе "CalcLogicImpl".
Добавление новой функции в логику калькулятора осуществляется в три шага:

1. Добавить в интерфейсе "Constants" в enum FUNCTIONS ещё один элемент с названием функции.

2. В теле метода "double doFunction(double value, FUNCTIONS typeFuncInBracket)" класса "CalcLogicImpl" добавить алгоритм вычисления результата с помощью данной функции. В переменной "double value" содержится значение, которое должно быть преобразовано данной функцией и записано в переменную "double result".

3. В теле метода "String outputStringFunctionOpen(InputData curInputData)" добавляется способ отображения самой функции в случае положительного или отрицательного знака. Можно делать по образцу функции извлечения квадратного корня.

Ещё один шаг нужно сделать для вью - добавить во вью новую кнопку с добавлением новой функции. Добавление новой функции осуществляется стандартным методом "String setNewFunction(Constants.FUNCTIONS typeFuncInBracket)", в параметр поторого как раз и нужно будет указать название функции из 1 шага.


### Настройка калькулятора и примеры работы с ним

Поскольку результат вычислений отображается на экране пользователя с конечными размерами, то настройка логики калькулятора заключается в том, что нужно передать в калькулятор разрешённое количество символов для отображения результата вычислений с помощью метода "void setMaxNumberSymbolsInOutputTextField(int maxNumberSymbolsInOutputTextField)".
В калькуляторе установлено по умолчанию 12 символов для вывода результата в виде строки, при использовании метода "getFinalStringResult()".

Поскольку калькулятор может быть установлен на различные устройста, как с большим дисплеем, так и с маленьким. То предусмотрено два решения: 1) для дисплеев с шириной экрана >=1080 px; 2) для дисплеев с шириной экрана <1080 px. Выбор способа отображения осуществляется автоматически в соответствии с параметрами текущего экрана при первом запуске приложения. Меняются как радиус расположения кнопок, так и сам радиус кнопок. Самостоятельно можно только поднастроить радиус расположения кнопок, с помощью изменения поля "int curRadiusButtons" через настройки калькулятора.

Вид экрана с настройками:

<p align="center">
<img  src="https://user-images.githubusercontent.com/78661461/195313838-1adc666c-6b6d-4329-8992-2c1dde2070bb.png">
</p>

Вид кнопок на дисплее с ширинок экрана >=1080 px:

<p align="center">
<img  src="https://user-images.githubusercontent.com/78661461/195307027-10a5d381-51d2-49eb-98ae-a6a8dfd57d2b.png">
<img  src="https://user-images.githubusercontent.com/78661461/195314122-bdabef54-bf07-49f2-b96c-87eeccc235a5.png">
</p>

Вид кнопок на дисплее с ширинок экрана <1080 px:

<p align="center">
<img  src="https://user-images.githubusercontent.com/78661461/195313736-fb743686-2fc3-45b7-9779-d868c0706ec0.png">
<img  src="https://user-images.githubusercontent.com/78661461/195315464-152ee38e-17bb-4435-a859-90bbb9f940ba.png">
</p>

Примеры вычислений на калькуляторе:
1. 6+7*(9-5)=34
```
Последовательность вызова функций калькулятора:
    - addNumeral(6);
    - setNewAction(Constants.ACTIONS.ACT_PLUS);
    - addNumeral(7);
    - setNewAction(Constants.ACTIONS.ACT_MULTY);
    - setNewFunction(Constants.FUNCTIONS.FUNC_NO);
    - addNumeral(9);
    - setNewAction(Constants.ACTIONS.ACT_MINUS);
    - addNumeral(5);
    - closeBracket();
    - calculate();
    - getFinalResult().
    Последовательность вычислений здесь будет следующая:
    1) 9-5=4;
    2) 7*4=28;
    3) 6+28=34;
```
2. (5+10%)+10%=6,05
```
Последовательность вызова функций калькулятора:
    - setNewFunction(Constants.FUNCTIONS.FUNC_NO);
    - addNumeral(5);
    - setNewAction(Constants.ACTIONS.ACT_PLUS);
    - addNumeral(1);
    - addNumeral(0);
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - closeBracket();
    - setNewAction(Constants.ACTIONS.ACT_PLUS);
    - addNumeral(1);
    - addNumeral(0);
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - calculate();
    - getFinalResult().
```
3. 10*10%=10
```
Последовательность вызова функций калькулятора:
    - addNumeral(1);
    - addNumeral(0);
    - setNewAction(Constants.ACTIONS.ACT_MULTY);
    - addNumeral(1);
    - addNumeral(0);
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - calculate();
    - getFinalResult().
```
4. 10/10%=10
```
Последовательность вызова функций калькулятора:
    - addNumeral(1);
    - addNumeral(0);
    - setNewAction(Constants.ACTIONS.ACT_DIV);
    - addNumeral(1);
    - addNumeral(0);
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - calculate();
    - getFinalResult().
```
5. 10+10%=11
```
Последовательность вызова функций калькулятора:
    - addNumeral(1);
    - addNumeral(0);
    - setNewAction(Constants.ACTIONS.ACT_PLUS);
    - addNumeral(1);
    - addNumeral(0);
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - calculate();
    - getFinalResult().
```
6. 10-10%=9
```
Последовательность вызова функций калькулятора:
    - addNumeral(1);
    - addNumeral(0);
    - setNewAction(Constants.ACTIONS.ACT_MINUS);
    - addNumeral(1);
    - addNumeral(0);
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - calculate();
    - getFinalResult().
```
7. (-6*7/9%)*(24^2/6+5%)%=4063,4920635
```
Последовательность вызова функций калькулятора:
    - setNewFunction(Constants.FUNCTIONS.FUNC_NO);
    - addNumeral(6);
    - changeSign();
    - setNewAction(Constants.ACTIONS.ACT_MULTY);
    - addNumeral(7);
    - setNewAction(Constants.ACTIONS.ACT_DIV);
    - addNumeral(9);
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - closeBracket();
    - setNewAction(Constants.ACTIONS.ACT_MULTY);
    - setNewFunction(Constants.FUNCTIONS.FUNC_NO);
    - addNumeral(2);
    - addNumeral(4);
    - setNewAction(Constants.ACTIONS.ACT_STEP);
    - addNumeral(2);
    - setNewAction(Constants.ACTIONS.ACT_DIV);
    - addNumeral(6);
    - setNewAction(Constants.ACTIONS.ACT_PLUS);
    - addNumeral(5);
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - closeBracket();
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - calculate();
    - getFinalResult().
    Последовательность вычислений здесь будет следующая:
    1) 7/9%=11.(1) - читается как 11 целых и бесконечное количество единиц после запятой, 
    т.е. 1 в периоде (11.111111111...);
    2) -6*11.(1)=-6,(6)e+01 - читается как -66 целых 
    и бесконечное количество шестёрок после запятой, т.е. 6 в периоде (-66,666666...);
    3) 6+5%=6,3;
    4) 24^2=576;
    5) 576/6.3=91,428571429;
    6) -66,6666666666*91,428571429%=4063,4920635
```
8.  -6*(-100)%=-36
```
Последовательность вызова функций калькулятора:
    - addNumeral(6);
    - changeSign();
    - setNewAction(Constants.ACTIONS.ACT_MULTY);
    - addNumeral(1);
    - addNumeral(0);
    - addNumeral(0);
    - changeSign();
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - calculate();
    - getFinalResult().
```
9.  2.863 * КОРЕНЬ(7+7+7*5)=20,041
```
Последовательность вызова функций калькулятора:
    - addNumeral(2);
    - setCurZapitay();
    - addNumeral(8);
    - addNumeral(6);
    - addNumeral(3);
    - setCurZapitay();
    - setNewFunction(Constants.FUNCTIONS.FUNC_SQRT);
    - addNumeral(7);
    - setNewAction(Constants.ACTIONS.ACT_PLUS);
    - addNumeral(7);
    - setNewAction(Constants.ACTIONS.ACT_PLUS);
    - addNumeral(7);
    - setNewAction(Constants.ACTIONS.ACT_MULTY);
    - addNumeral(5);
    - closeBracket();   
    - setNewAction(Constants.ACTIONS.ACT_PERC_MULTY);
    - calculate();
    - getFinalResult().
    Последовательность вычислений здесь будет следующая:
    1) 7+7+7*5=49;
    2) КОРЕНЬ(49)=7;
    3) 2.863*7=20,041.
```

## Условия использования приложения

Код приложения предоставляется в рамках "MIT License". Вы можете использовать этот код как вам будет угодно. Если в процессе работы с кодом у вас возникнут вопросы, вы сможете их задать мне по электронной почте avkhakhalin@mail.ru 
В теме письма укажите "Вопрос по Scientific calculator". 
Постараюсь по мере сил ответить на все технические вопросы.

## Дальнейшие шаги по улучшению приложения

Ближайшими шагами по доработке калькулятора являются:

1. Добавить функцию факториала.

2. Добавить действие с вычислением процента в формате: A%B, где A - число, от которого нужно вычислить процент, а B - величина процента, которую нужно определить.

3. Добавить тригонометрические функции.

4. Добавить возможность задавать исходные данные через строку.

5. Добавить возможность задавать собственную функцию.


## Способы выразить благодарность автору

Если есть желание поддержать мою работу по данному калькулятору или выразить благодарность 
за проделанную работу, то можете это сделать переводом на мой телефон: +7-905-536-45-06 или на мой счёт,
привязанный к данному телефону в банке ВТБ (ПАО).

Также можете заказать внедрение в калькулятор собственных решений для экономии собственного времени.

Просто «спасибо» тоже приветствуется @avkhakhalin (Телеграмм) ;) 

Ведь делаю калькулятор для других, как для себя.
